# Diary

* 2018/1/1
    * 明けましておめでとうございます！今年もよろしくお願いします！
    * 夜の時に東京タワーへ行きました。
    
* 2018/1/2
    * 今天都在混,懶癌末期,連吃飯都懶了
    * System.getProperty("line.separator"); 換行正式點的寫法
    * enhanced for loop 加強版的for迴圈(!?)

* 2018/1/3
    * 出門跟西西逛了一下,又不小心手滑買了一些
    * 課本要是也能出個升級版就好了,筆記一下寫法XDDD

      private LocalDate createDate(int year, int month, int dayOfMonth) {
      return LocalDate.of(year, month, dayOfMonth); }

      createDate(2018, 1, 4)

      OR

      Private LocalDate createDate(int year, Month month, int dayOfMonth) {
      return LocalDate.of(year, month, dayOfMonth); }

      createDate(2018, Month.JANUARY, 4)

     * 發現搞不懂的東西還是一大堆,覺得ヤバイ

* 2018/1/4
    * 跟謝桑還有林桑一起出門逛街,晚餐吃了吉野家
    * 整理行李,發現公斤數爆了...只能繼續留東西在日本了XD
    * 課本p.110~112 Date部分的重構與測試看不是很懂 先寫看看再說好了(?)

* 2018/1/5
    * 中午肯德基,晚餐薄利多銷半兵衛,以後還是少去居酒屋好了,抽菸的人太多不喜歡...
    * 買了些零食,加了五公斤,真的變得好窮唷XDDD

* 2018/1/6
    * 整理行李真的很累,尤其是測量的時候,很難提起來量!!!
    * 下午大概四點半就出門了,有點太早到機場,現在機場管制變嚴格了Q_Q
    * 晚上10:00準時起飛回台灣

* 2018/1/7
    * 半夜1:15準時抵達,下雨的關係吧,降落的時候完全沒感覺欸
    * 一路等到早上六點的車,還認識了一位計程車司機XD
    * 大概九點左右終於回家了嗚嗚,整理行李地獄

* 2018/1/8
    * 家裡太好睡,一路睡死到下午,沒有宅急便會來按門鈴XDDD
    * 書房跟房間稍微整理一下,晚餐的飯煮的有點失敗,再接再厲
    * 回來繼續當尼特了,加油唸書唸書唸書

* 2018/1/9
    * 看了白皮書,覺得良葛格寫的真的很詳細(跪拜
    * Java三大平台 = Java SE, Java EE, Java ME
    * Java SE8 = Java Platform, Standard Edition 8
    * JVM = Java虛擬機(Java Virtual Machine),包括在JRE中,
      Java只認識JVM作業系統,將原始的.java檔經過編譯後成為.class檔的位元碼(byte code)
    * JRE = Java執行環境(Java Runtime Environment),包括了Java SE API
      (Application Interface)和JVM,如果只是要跑java檔的話,安裝JRE就夠了
    * JDK = Java開發套件(Java Development Kit---O  Java Developer Killer---X),
      包括了Java程式語言、工具程式和JRE,也就是涵蓋全部,作為寫Java最基本的工具包,
      但準備相關開發環境很不友善Orz
    * path(作業系統讀的)/classpath(JVM讀的) = 路徑(パス)讓電腦去尋找java檔來執行用/是讓JVM去找.class來執行
    * .java檔放在src資料夾裡/.class檔放在target資料夾裡
    * 程式庫中的類別檔案,會封裝為JAR(Java Archive)檔案,也就是.jar檔,
      JAR檔案實際使用ZIP格式壓縮,當中包含一堆.class檔案
    * javac = 編譯器(Java Compiler)
    * 明天再把第二章重看一次~有看沒有懂XDDD

* 2018/1/10
    * 把第二章又看了一遍,果然還是很難懂,特別是對編譯器下指令的部分
    * -sourcepath 指定編譯器從src資料夾中尋找原始碼檔案
    * -d 指定了編譯完成的位元碼存放資料夾
    * -verbose 可以看到編譯器進行編譯時的過程
    * -cp(-classpath) 啟動JVM時要告知執行檔(.class)的位置則使用此引數指定
    * -version 引數顯示執行的JRE版本
    * -target 指定編譯出來的位元碼必須符合指定平台所允許的版本號
    * -source 要求編譯器檢查使用的語法,不超過指定的版本
    * Bootstrap類別載入器(Class loader) 17章會說明
    * --release 一次指定-source、-target和-bootclasspath
    * package所定義名稱和class所定義名稱,會結合成類別的完全吻合名稱(Fully qualified name)
    * IDE = Integrated Development Environment 開發環境
    * import 是告訴編譯器,遇到不認識的類別名稱,可以嘗試使用import過的名稱,
      在指定的類別中找到檔案進行編譯
    * 電腦中可能存在多套JRE,到一個新開發環境下,先確認版本是很重要的
    * JDK本身內部有的是Private JRE,另一個是選擇安裝的Public JRE
    * 若設定path包括JDK的bin資料夾,則是會找到Private JRE
    * 若設定path包括Public JRE的資料夾,則是用Public JRE

* 2018/1/11
    * 今天把第三章基礎語法看完了,覺得有點讀太慢,七成都是看過的東西Q_Q
    * Java可區分為基本型態(Primitive type)和類別型態(Class type)亦稱為參考型態(Reference type)兩大型態系統
    * 基本型態可分為 整數、位元組、浮點數、字元、布林
    * JDK9中,Java的字元支援Unicode 8.0,JVM實作採UTF-16 Big Endian
    * 雖然我只稍微看了一下... [〈Unicode與UFT〉](https://openhome.cc/Gossip/Encoding/UnicodeUTF.html)
    * 如果儲存值超出型態範圍稱之為溢值(Overflow)
    * printf()的f是format的意思,也就是格式化
    * 常用的格式控制符號 %%、%d、%f、%e,%E、%o、%x,%X、%s,%S、%c,%C、%b,%B、%h,%H、%n
    * %d：以十進位格式輸出
    * %f：以十進位浮點數格式輸出
    * %e,%E：以科學記號浮點數格式輸出,%e表示輸出格式遇到字母以小寫表示,%E反之
    * %o：以8進位整數格式輸出
    * %x,%X：以16進位整數格式輸出
    * %s,%S：字串格式符號
    * %c,%C：以字元符號輸出
    * %b,%B：輸出boolean值,非null值輸出是true或TRUE,null值輸出是false或FALSE
    * %h,%H：使用Integer.toHexString(arg.hashCode())來得到輸出結果,如果arg是null,則輸出null
    * %n：輸出平台特定的換行符號,Window會換成"\r\n",Linux會換成'\n',Mac OS會換成'\r'
    * 忽略(Escape)符號\ ,編譯器看到\就會忽略下一個字元,例如要表示'就要用\加' (這邊也會忽略XDDD)
    * 比較運算子(Comparison operator)：>、>=、<、<=、==、!=
    * 條件運算子(Conditional operator)：條件式結果為true,則傳回：前的值,若為false,則傳回：後的值
    * 邏輯運算子(Logical operator)：&&、||、! , 其中&&和||有所謂捷徑運算(Short-Circuit Evaluation)
    * 位元運算子(Bitwise operator)：&(AND)、|(OR)、^(XOR)、~(補數) , [再讀一次真值表](https://zh.wikipedia.org/wiki/真值表)
    * 位元運算上,Java還有左移(<<)與右移(>>),左移會將最左邊的位元丟棄,右邊補上0;右移會將最右邊的丟棄,左邊補上原來的位元(看是1還是0)
    * 還有一個>>>運算子,這個運算子在右移後,左邊必定補上0
    * 重要觀念：不要對浮點數作相等性運算(!?)
    * break和continue可以配合標籤使用,例如本來break只會離開for迴圈,設定標籤與區塊,則可以離開整個區塊;continue配合標籤,可以自由地跳至任何一層for迴圈
    * 醒來後把第三章的程式碼部分打一打練習一下

* 2018/1/12
    * 今天跟迪西阿哈蛋蛋到阿丁家吃飯聊天,然後錢錢居然還記得我XDDD
    * 後來迪西阿哈蛋蛋來到家裡,給她悶參觀我宅到不行的祭壇了(ry),阿哈表示也想買模型,傳教成功(不
    * 今天HEN混只打了幾行來練習|||
    * 姊姊回家,秀秀買了雞排肥來!!!

* 2018/1/13
    * 中午起來出發吃小蒙牛,結果秀秀訂錯店XDDD...覺得小蒙牛真的好吃
    * 下午去阿嬤家後,原本說不吃晚餐,但最後還是吃了一堆東西!!!
    * 薯條三兄弟被老媽拿走了,原來她比較喜歡這種零食

* 2018/1/14
    * 下午莉惠來家裡,收到她手工做的餅乾還有バッチ,讚~~~
    * 歌頌姊姊大人,收購餅乾還不帶回去新竹給我吃餅乾自助吧(肥
    * 晚餐是酸菜白肉飯,超級好吃的啊!!! 在台灣最大的樂趣就是吃了啊!!!
    * 我終於把第三章的練習給打完了(混

* 2018/1/15
    * 蛋黃酥好好ㄘ哦喔喔喔
    * 把第四章看完了,當然還是有很多地方不太懂,明天把第四章程式碼練習一次
    * 產生物件必須先定義類別(class),類別是物件的設計圖,物件是類別的實例(Instance),建立實例要用new關鍵字
    * 類別名稱宣告的變數稱為參考名稱(Reference name)、參考變數(Reference variable)或直接叫做參考(Reference)
    * 參數名稱與物件資料同名時,可以在資料成員前使用this關鍵字作為區別
    * 要取得使用者輸入,可以使用System.in物件上的read()方法,也可以使用java.util.Scanner代勞
    * Scanner的nextInt()方法會看標準輸入中有無輸入下一個字串(以空白或換行為區隔),有的話會嘗試將之剖析為int型態
    * 除了nextInt以外,也有其他對應方法(nextByte.nextShort.nextLong...等)
    * 如果直接取得上一個字串(以空白或換行為區隔),則使用next(),想取得使用者輸入的整行文字,則使用nextLine()(以換行為區隔)
    * Java和其他程式語言,遵合 IEEE 754 浮點數演算(Floating-point arithmetic)規範,使用分數與指數來表示浮點數(0.75會使用1/2 + 1/4來表示),所以無法精確表示
    * 要求精確度的話,可以使用java.math.BigDecimal類別,提供有add().subtract().multiply().divide()..等方法
    * 比較兩個物件的內容(字串跟new物件等)是否相同要利用equals()方法,而非==運算子
    * 要讓基本型態像物件一樣操作,可以使用Long.Integer.Double.Float.Boolean.Byte等類別來包裹(Wrap)基本型態,這些類別就是所謂的包裹器
    * Integer.valueOf()也是為基本型態建立包裹器的方法之一
    * 在Java程式碼中,null代表一個特殊物件,任何類別宣告的參考名稱都可以參考至null,表示該名稱沒有參考任何實體物件
    * 陣列(Array)在Java中,就是物件,是具有索引(Index)的資料結構(從0開始),一旦建立長度就固定了
    * 從JDK5開始有增強式for迴圈(Enhanced for loop),是為全跑的迴圈 (但是我還不太熟怎麼用XD)
    * 陣列複製的System.arraycopy().System.copyOf(),用在類別型態宣告的陣列時,都是執行淺層複製(Shallow copy)
    * 字串代表一組字元,是java.lang.String類別的實例,字串物件一但建立就無法更動內容,此特性又稱作不可變(immutable)
    * 使用+串接字串會產生新的String實例,盡量不要將+用在重複性的串接場合

* 2018/1/16
    * 明明回暖了卻還是睡很晚,調不過來的作息!!!
    * 今天把第三章的實作題給練習完了(雖然花了很多時間),複習了輾轉相除法和學到了阿姆斯壯數XDDD
    * 第四章的內容還沒練習完,實作題也還沒寫,明天繼續加油

* 2018/1/17
    * 把第四章的內容練習一次了,可是實作題四題裡面只會一題...洗牌想先跳過,還剩一題沒寫啊啊啊
    * 學了費式數列,突然覺得遞迴很可怕
    * 今天秀秀又買了炸炸回來,吃得好開心,可是會肥XDDD

* 2018/1/18
    * 在紅燈下度過的一天,晚上幾乎都在跟けいけい聊天XDDD,發現她其實比我想得正常(X
    * 學了Arrays.sort()方法(遞增的排序)還有binarySearch()方法(尋找索引),也練習了List.indexOf()方法
    * 看別人寫都很簡單,改成自己想要的形式就會開始不斷被閃紅燈...Orz
    * [java.util包](http://tw.gitbook.net/java/util/collections_shuffle.html#)
    * 之後寫洗牌會用到上面的方法,先存下來,測試也要寫,越欠越多!!!
    * Arrays.binarySearch()方法,若是找不到值,則會傳回"負數"
    * 回傳是負數的部分, 他回的計算方式是: (-(insertion point) - 1)
    * 拿到-2可以這樣解讀: -2的"-"代表這個數不存在,然後2表示這個數若存在, 應該被塞在第二個, 但這邊的2不是index, 是說這個陣列的"第二個"
    * 若輸入0,卻找不到時會傳回-1; 若輸入100,找不到時會傳回-10,程式會判斷要塞在陣列的哪個位置

* 2018/1/19
    * 今天廖紫嵐回來,然後我晚餐的飯不小心煮太多XDDD 雖然煮得很成功~~~
    * 今天把第五章物件封裝(Encapsulation)看完了,第六章看到一半明天繼續
    * 建構式實現物件初始化流程的封裝,方法封裝了操作物件的流程
    * Java中還可以使用private封裝物件私有資料成員
    * 如果定義類別時,沒有撰寫任何建構式,編譯器會自動加入一個無參數、內容為空的預設建構式(Default constructor)
    * 但如果是自己寫的無參數建構式的話,就不是預設建構式了,而只是一個Nullary建構式
    * 可以建立多個建構式,只要參數型態或個數不同即可,這稱為重載(Overload)建構式
    * 被宣告為static的成員,不會讓個別物件擁有,而是屬於類別
    * 在命名慣例下,看到字首大寫(System.out)就知道它是類別,透過類別名稱與.運算子來存取,就會知道它是static成員
    * 在static方法或區塊中不能出現this關鍵字,也不能用非static資料或方法成員
    * 不定長度引數(Variable-length Argument),宣告參數列時要於型態關鍵字後加上...
    * 使用不定長度引數時,方法上宣告的不定長度參數必須是參數列最後一個,使用兩個以上是不行的

* 2018/1/20
    * 跟璟慧去一中街,吃了韓34,還喝了阿月的白玉珍珠奶茶,以後要點無糖XDDD
    * 幫璟慧挑一些衣服給她試穿,她不會打扮的程度到我都看不下去了 囧
    * 還被路人搭話聊天,問我是高中生還是已經大學生了,覺得很爽XD 歲月不饒人阿
    * 把祭壇重新整理一次,很多經典漫畫可以拿出來睡前重看一下
    * 晚上看了電視播的一個大陸電影,好像叫老炮兒吧,演員演得不錯,只是劇情有點沉重啊

* 2018/1/21
    * 下午在看刀劍亂舞的アンソロジー,然後居然在5-4王關撿到三日月...
    * 晚餐吃了麥當當,發現六塊雞餐不夠吃XDDD 還好秀秀包了佛跳牆回來
    * 第六章繼承(Inherit)與多型(Polymorphism)讀完啦～
    * 物件導向中,子類別繼承父類別,避免重複的行為與實作定義,重複在程式設計上就是不好的訊號
    * 繼承的關鍵字為extends,private成員也會被繼承,只不過子類別無法直接存取
    * 若打算只讓子類別存取父類別的private成員的值,可以將他們定義為"protected"
    * 子類別只能繼承一個父類別,它們之間會有is-a的關係,中文稱為"是一種"的關係,例如:貓是貓科,老虎也是貓科,但貓科不一定就是貓或老虎
    * 所以Role role1 = new SwordsMan(); > 劍士是一種角色 但反之角色不一定是劍士
    * 可以透過扮演(CAST)來通過編譯 SwordMan swordMan = (SwordMan) role1; 但不一定所有扮演都會成功
    * 要理解多型之前,必須先知道你操作的物件是"哪一種"東西
    * 多型,以抽象講法解釋,就是使用單一介面操作多種型態的物件!
    * Java以繼承及介面來實作多型,是次型態(Subtype)多型的一種實現
    * 在繼承父類別之後,定義與父類別中相同的方法簽署(method signature),但實作內容不同,這稱為重新定義(Override)
    * 在JDK5之後支援標註(Annotation),其中一個標註就是@Override
    * 如果在子類別中某個方法前標註@Override,表示要求編譯器檢查,該方法是不是真的重新定義了父類別中某個方法,如果不是就會引發編譯錯誤
    * 若某個方法區塊中真的沒有任何程式碼實作,可以使用abstract標示該方法為抽象方法(Abstract method),該方法不用寫{}區塊,直接;結束即可
    * 類別中若有方法沒有實作,並標示為abstract,表示這個類別定義不完整,就不能用來生成實例
    * Java中規定內含抽象方法的類別,一定要在class前標示abstract,表示這是一個定義不完整的抽象類別(Abstract class)
    * 子類別如果繼承抽象類別,對於抽象方法有兩種作法,一種作法是繼續標示該方法為abstract(如果是類別就標在class前),另一種作法是實作抽象方法
    * Java中三個權限關鍵字為public.protected.private,若沒有定義權限關鍵字,預設就是套件範圍
    * 權限小至大 private < 無關鍵字 < protected < public ,如果一開始不知道使用哪個權限就先用private
    * 如果想取得父類別中的方法定義,可以於呼叫方法前加上super關鍵字
    * 重新定義方法要注意,對於父類中的方法權限,只能擴大但不能縮小
    * 如果子類別建構式中沒有指定執行父類別中哪個建構式,預設會呼叫父類別中無參數建構式
    * 如果想執行父類別中某建構式,可以使用super()指定,但this()與super()只能擇一呼叫,而且一定要在建構式第一行執行
    * 若class前使用了final關鍵字定義,那麼表示這個類別是最後一個了,不會再有子類別,也就是不能被繼承
    * 也可以限定方法為final,表示這是最後一次定義方法了
    * 如果定義類別時,沒有使用extends關鍵字指定繼承任何類別,那一定是繼承了java.lang.object
    * JVM有垃圾收集(Garbage Collection, GC)機制,無法透過變數參考(沒有牌子)的物件就會被當成垃圾
    * 欠了很多練習題,明天要好好練習了啊啊啊!!!

* 2018/1/22
    * 把花のみぞ知る重看一次,獲益良多(?
    * 去了郵局跟便利商店贖人,出門遇到姊姊高中同學的爸爸,然後竟然被問是不是她姊姊(哇哇哇
    * 把第五章的範例給練習完了,第六章還有一半,很多練習題也都還沒頭緒,とにかく、やってみよう～

* 2018/1/23
    * 第六章的範例練習完了,可是實作題不會寫...寫了一堆亂七八糟的東西都不知道在幹麻了
    * 跟老爸一起看相撲,日馬富士引退真的很可惜呀

* 2018/1/24
    * 寫了一些程式的測試,不過不知道對ㄅ對就是哈哈哈
    * 上了一課,學了重新定義toString()跟equals()還有三元運算子(condition) ? (Y) : (N),例外處理


* 2018/1/25
   * 今天完全沒寫出像樣的東西 囧 發現很多東西都搞不懂 像是ArrayList...
   * 還有物件為什麼傳不進去還有為何不能重新定義還有測試到底要怎摸寫 ㄜ啊啊啊

* 2018/1/26
   * 讀了Aarray跟AarrayList [連結](http://peter711002.blogspot.tw/2014/08/javaarray-and-arraylist.html)
   * 把課本的內容複習一下,搞不太懂的東西還很多
   * 教了阿丁N3的文法,看來還有很長的路要走...Orz
   * 今天秀秀又買雞排回來了!!! OMG!!! 會肥死!!!

* 2018/1/27
   * 陳聖麒來台中,帶他逛了一中跟台中公園,吃了亞丁尼跟喝了珍奶~~~
   * 原來他已經33歲了,下面還有兩個妹妹,完全不知道!!! (震驚
   * 阿丁的基礎真的不行,看來還是得慢慢教,以為他自己會好好讀熟,高估了 囧

* 2018/1/28
   * 昨天難得早睡,結果今天還是一樣晚起,沒救了
   * 今天都在恍神沒做什麼,玩了整個下午,還聊了整個晚上的天 囧

* 2018/1/29
   * 終於把Fate/Apocrypha補完了,やはりカルナは最高だ！
   * 老爸的同事,吳小姐人真的超好~幫自己的小小人買了餅乾就算了,還買來給老爸要讓我吃XD
   * 今天上課,終於把實作題給解決了Q_Q!!! 覺得自己腦袋轉不過來就是
   * 一個class只能繼承一個一個父類別,但是可以操作數個介面(interface)
   * 介面就像合約的感覺,必須將裡面的方法實作好
   * @Override重新定義的話,連參數都必須一併照樣寫上,不然不會通過

* 2018/1/30
   * 跟阿丁.蛋蛋.迪西.阿哈一起去新時代吃21烤雞!!! 覺得滿足~~~
   * 把第七章介面與多型看完了,明天開始練習範例,肚子好餓喔
   * 對於定義行為,可以使用interface(介面)關鍵字定義
   * 介面中的方法可以不實作,直接標示為abstract,而且一定是public
   * 以Java的語意來說,實作介面表示"擁有行為",不是"是一種"的關係
   * 對於介面多型語法的判斷,方式是"右邊是不是擁有左邊的行為"或是"右邊的物件是不是實作了左邊的介面"
   * 類別只能繼承一個父類,但是可以實作多個介面,也就是可以擁有兩種以上的行為
   * 使用interface來定義抽象的行為外觀,方法要宣告為public abstract,且不能有實作(為了方便也可以省略public abstract,編譯器會自動補齊)
   * 可以使用介面列舉常數,只能定義為public static final(但同上能省略)
   * 介面可以繼承別的介面,也可以同時繼承兩個以上的介面,同樣也是用extends關鍵字,代表了繼承父介面的行為
   * 如果有臨時繼承某個類別或實作某個介面並建立實例的需求,而這類子類別或介面實作類別只使用一次,可以使用匿名內部類別(Anonymous inner class)來解決這個需求
   * JDK5後新增了enum語法,可用於定義列舉常數
   * enum定義了特殊的類別,繼承自java.lang.Enum,不過這是由編譯器處理,直接撰寫程式繼承Enum類別會被編譯器拒絕
   * enum實際上定義了類別,而enum中列舉的常數,實際上是public static final,且為列舉型態實例,無法直接撰寫程式實例化列舉型態,因為建構式權限限定為private,只有類別中才可以實例化

* 2018/1/31
   * 抽不到女帝啊!!!(崩潰
   * 今天有藍血月,可是下雨看不到,只好看日本傳來的照片Q_Q
   * 7-1的範例練習完了,測試也寫了,剩下明天繼續
   * 喝了五十嵐的紅茶拿鐵微糖,好喝
   















