# Diary

* 2018/3/1
  * 第十章的實作第一二題大致上都讀懂了,不過第一題還沒設定log,然後第三題我就真的看無了
  * 讀Diary of a Wimpy Kid
  * 不小心就把ヲタクに恋は難しい追到新進度了XDDD...很對於阿宅部分的描述真的是很寫實(O
  * 明天讓我來讀讀Lambda吧!!! GOGOGO!!!

* 2018/3/2
  * 讀Diary of a Wimpy Kid
  * 讀第十二章Lambda,覺得有稍微懂一些了(?) 然後原來::是方法參考(Method reference) 之前害我文盲好多次XDDD
  * 今天元宵節~秀秀回來買了雞排跟湯圓,然後沒想到現在電視居然還有在播靈異教師神眉!!!

* 2018/3/3
  * 超級熱的一天,陪璟慧去一中逛逛XDDD,只是璟慧都不聽偶的意見,討M~~~
  * 晚上吃麻辣鴨血鍋,吃完打麻將,難得大勝的一次,還很好運地海底自摸
  * 結果今天只看了小丸子的慣用句書後就睡了

* 2018/3/4
  * 姐姐表示跟老爸講錯結果早餐買到蛋餅,為了表示歉意她幫我吃了一塊(好像哪裡怪怪ㄉ???????
  * 後來中午去中國醫的星巴克,覺得摩卡跟可可好像差不多,以後我喝可可就好了(?
  * 下午去剪了頭髮,終於告別我那稻草般的長髮了XDDD (保養一下好嘛
  * 跟好久沒聊的幸均小聊了一下,後來就洗洗睡,唸Diary of a Wimpy Kid

* 2018/3/5
  * 今天也好熱我的天,老爸看牙醫拔了三顆牙,一直在流血 囧
  * 讀Diary of a Wimpy Kid and 第十二章Lambda

* 2018/3/6
  * 讀 Diary of a Wimpy Kid
  * 第十二章看很久,有點看不下去後就拿了資料結構來看看
  * [Java泛型的轉換](https://magiclen.org/generic-convert-extends-super/)
  * [Java检查非null值](https://majing.io/posts/10000005401188)
  * [What is the difference between List.of and Arrays.asList?](https://stackoverflow.com/questions/46579074/what-is-the-difference-between-list-of-and-arrays-aslist)

* 2018/3/7
  * 讀 Diary of a Wimpy Kid
  * 讀完大話資料結構第二章
  * 資料結構與演算法的關係是互相依賴,不可分割的
  * 演算法的定義:演算法是解決特定問題求解步驟的描述,在電腦中為指令的有限序列,且每條指令表示一個或多個操作
  * 演算法特性:有限性、確定性、可行性、輸入、輸出
  * 演算法設計的要求:正確性、可讀性、健壯性、高效率以及低存取量需求
  * 特性與設計的要求這兩者容易混淆,得務必小心謹慎
  * 演算法的度量方法:事後統計方法(不科學、不準確)、事前分析估算方法
  * 如何使用事前分析估算方法,先是提出了函式漸進增長的定義
  * 函式漸進增長:給定兩個函式f(n)和g(n),如果存在一個整數N,使得對於所有的n>N,f(n)總是比g(n)大,如此可以發現,f(n)的增長將漸快於g(n)
  * 於是可以得出一個結論,就是若要判斷一個演算法的好壞,只透過少量的資料式無法做到準確判斷的,如果可以比對這些演算法之間執行次數函式的漸進增長性,就可以分析出某個演算法是隨著n的變大而愈來愈優(劣)於另一個演算法
  * 所以有了演算法時間複雜度的定義,以及推論Big O符號的步驟如下: (1) 用常數1取代執行時間中的所有加法常數 (2)在修改後的執行次數函式中,只保留最高次項 (3) 如果最高次項存在且不是1,則去除與這個項相乘的常數 => 得到的結果就是Big O符號
  * 常見的時間複雜度所需時間的小至大排列:
  * O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O (n^3) < O(2^n) < O(n!) < O(n^n)
  * [Are there any real O(n^n) algorithms?](https://stackoverflow.com/questions/6156224/are-there-any-real-onn-algorithms)

* 2018/3/8
  * 讀 Diary of a Wimpy Kid
  * 讀大話資料結構,雖然有試著去寫裡面的範例,但我發現我轉換不過來...
  * [要記得看這個](https://www.udemy.com/data-structure-and-algorithms-analysis/)

* 2018/3/9
  * 讀 Diary of a Wimpy Kid
  * 讀資料結構
  * 只好暫時繼續留在台灣(?

* 2018/3/10
  * 讀 Diary of a Wimpy Kid
  * 下午幸均來家裡找我教他日文,然後我們好像玩的有點太開心了(x

* 2018/3/11
  * 寫中日文自傳
  * 讀 Diary of a Wimpy Kid
  * 讀 Java版本的鏈結串列

* 2018/3/12
  * 丟履歷,明天再繼續丟一些看看
  * 讀 Diary of a Wimpy Kid
  * 繼續讀LinkedList,我對這個有點學習障礙 囧

* 2018/3/13
  * 結果又在丟一次履歷了...
  * 讀 Diary of a Wimpy Kid
  * 繼續看資料結構

* 2018/3/14
  * 打電話去問職缺了,結果後來他們馬上關閉職缺...看來凶多吉少ㄌ
  * 讀 Diary of a Wimpy Kid
  * 今天讀鏈結串列莫名都看得懂了,我好像有點開竅了!!!(開心

* 2018/3/15
  * 繼續亂投履歷
  * 讀 Diary of a Wimpy Kid
  * 資料結構第三章看完了...沒到全部懂,但理論大概都理解了

* 2018/3/16
  * 收到面試通知了,居然要等到27號...
  * 讀 Diary of a Wimpy Kid
  * 今天看了資料結構堆疊的部分(Stacks),覺得都還算蠻好懂的
  * 堆疊是規定只能在尾端進行插入和刪除等作業的線性串列
  * 允許插入和刪除的一端稱為堆疊頂端(Top),另一端則稱為堆疊底端(Bottom),不含任何資料元素的堆疊稱為空堆疊
  * 堆疊又稱為後進先出(Last In First Out; LIFO) 的線性串列,簡稱"LIFO結構"
  * 堆疊的插入稱為進堆疊(Push),也稱為推入堆疊
  * 堆疊的刪除作業稱為出堆疊(Pop),也較彈出堆疊
  * 以陣列編號為0的一端選擇堆疊底端會比較好,因為首元素都存在底端,變化也最少
  * 插入/進堆疊(Push)和彈出/出堆疊(Pop) 均未涉及到任何迴圈語句,因此時間複雜度皆為O(1)
  * 兩堆疊為一個儲存空間固定的陣列中,分成兩個堆疊,位於陣列兩端,並向中間靠攏
  * top1 + 1 == top2 即為堆疊滿了
  * 通常會使用這樣的資料結構都是當兩個堆疊空間需求有相反關係時,也就是一個堆疊在增長時,另一個就在縮短,就像買賣股票,有人買入有人賣出
  * 堆疊的鏈結儲存結構簡稱為鏈結堆疊,基本上是不會出現堆疊是滿的情況(除非記憶體爆ㄌ)
  * 鏈結堆疊的插入和刪除的時間複雜度也皆為O(1)  <<<但是我還不會寫程式囧
  * 無法預先估計元素的變化有時很小有時非常大,那就使用鏈結堆疊; 反之,如果變化在可控制範圍內,則建議使用順序堆疊
  * 遞迴與四則運算的求值皆為堆疊的應用
  * 一個直接呼叫自己或透過一系列的呼叫語句、間接地呼叫自己的函式,稱做"遞迴函式"
  * 每個遞迴定義必須至少有一個條件,當滿足時,則遞迴便不再進行,即不再引用自身,而是回傳值然後退出
  * 藉由費伯納西數列的程式碼可以得知,反覆運算和遞迴的區別在於: 反覆運算使用的是迴圈結構,而遞迴使用的則是選擇結構,讓人更好讀懂程式  <<<我終於了解為啥程式會跑這麼龜了...
  * 平常我們所使用的標準四則運算運算式稱為中序運算式
  * 波蘭有位邏輯學家想到了一種不需要括號的表記法,稱為逆波蘭記法
  * 後序式運算式,之所以稱為後序式的原因,在對於所有的符號都是用來運算的數字後方出現
  * [逆波蘭表示法/後綴表示法/後序式記法](https://zh.wikipedia.org/wiki/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95)
  * 中序運算式: 9+(3+1)x3+10÷2  -> 後序式運算式: 9 3 1 -3*+ 10 2 /+
  * 運算的方法則是應用了堆疊方法來運算  <<<稍微有練習了一下怎麼算,覺得這個挺有趣的

* 2018/3/17
  * 讀 Diary of a Wimpy Kid
  * 讀資料結構,佇列(Queue)的部分
  * 把第四章的內容給看完了,程式部份還未操作
  * 佇列是只允許在一端進行插入操作,而在另一端進行刪除作業的線性串列
  * 佇列是一種先進先出(First In First Out ; FIFO) 的線性串列, 允許插入的一端稱為隊尾(Rear), 允許刪除的一端稱為隊首(Front)
  * 頭尾相接的順序儲存結構稱為環狀佇列
  * 環狀佇列滿的條件則是 (rear + 1) % QueueSize == front (取餘數%的目的就是為了整合rear與front大小問題)
  * 通用計算佇列長度公式為: (rear - front + QueueSize) % QueueSize (由於會有 rear > front 及 rear < front 兩種情況)
  * 佇列的鏈結儲存結構,其實就是線性串列的單向鏈結串列,只不過它只能尾進頭出而已,簡稱鏈結佇列
  * 空佇列時,front和rear都指向首節點
  * 進入佇列的話,就是在鏈結串列尾部插入節點(尾插法!?
  * 離開佇列時,就是首節點的後繼節點離開,將首節點的後繼者改成它後面的節點,若鏈結串列除了首節點以外,只剩一個元素時,則須將rear指向首節點
  * 環狀佇列(Circular Queue)與鏈結佇列的基本操作都是常數時間,即O(1)
  * 確定佇列長度最大值的情況下,建議用環狀佇列; 如果無法知道長度時,則使用鏈結佇列(較靈活

* 2018/3/18
  * 讀 Diary of a Wimpy Kid
  * 讀資料結構堆疊跟佇列的程式部分,明天繼續往下讀

* 2018/3/19
  * 結果真的去關說了XDDD
  * 讀 Diary of a Wimpy Kid
  * Queue程式部分搞懂了,課本繼續往下看,樹的部分看了一半,明天應該可以看完

* 2018/3/20
  * 讀 Diary of a Wimpy Kid
  * 大話資料結構勾選的章節讀完一輪了,不過還不太會分析樹的結構
  * 字串的鏈結儲存結構除了方便執行字串與字串的連接外,其餘並不如順序儲存靈活,效能也不如順序儲存結構
  * 樹的定義: 樹是n(n≧0)個節點的有限集合, n=0時稱為空樹
  * 在任意一顆非空樹中: 1.存在一個唯一特定的根(root)節點  2.當n>1時,其餘節點可分成為m(m>0)個互不相交的有限集合T1,T2....,Tm,其中每一個集合本身又是一棵樹,並且稱為根的子樹(SubTree)
  * 節點擁有的子樹數量稱為該節點的度(Degree)
  * 度為0的節點稱為葉子節點(Leaf),或終端節點(Terminal Node)
  * 度不為0的節點稱為分支節點(Branch)或非終端節點(Non-Terminal Node),除了根節點之外,分支節點也稱為內部節點(Internal Node)
  * 節點的子樹之根稱為該節點的孩子(Child),相對地,該節點則稱為孩子的(Parent),而同個雙親的孩子之間互稱兄弟(Sibling)
  * 樹中節點最大階度稱為樹的深度(Depth)或高度(Height)
  * 如果將樹中節點的子樹看成是由左至、有次序且不能互換的,則稱該樹為有序樹,否則稱為無序樹
  * 森林(Forest)是m(m≧0)棵互不相交的樹的集合
  * 樹的儲存結構有三種不同的標記法: 1.雙親標記法 2.孩子標記法 3.孩子兄弟標記法
  * 雙親標記法: 以一組連續空間儲存樹的節點,同時在每個節點中,附設一個指標來指示其雙親節點到鏈結串列中的位置,也就是說除了知道自己是誰外,還知道雙親是誰
  * 多向鏈結串列: 即每個節點有多個指標欄位,其中每個指標指向一棵子樹的根節點,這種方法稱為"多重鏈結串列標記法"
  * 孩子標記法: 具體作法是把每個節點的孩子節點排列起來,以單向鏈結串列作為儲存結構,則n個節點有n個孩子鏈結串列,如果是葉子節點,則此單向鏈結串列為空。然後,n個首指標又組成一個線性串列,採用順序儲存結構,存入一個一維陣列中
  * 孩子兄弟標記法: 任何一棵樹,其節點如果有第一個孩子就是唯一的,如果有右兄弟存在也是唯一的。因此,可以設置兩個指標,分別指向該節點的第一個孩子及此節點的右兄弟
  * 孩子兄弟標記法最大的好處就是把一顆複雜的樹變成了二元樹(Binary Tree)
  * 二元樹是n(n≧0)個節點的有限集合,該集合或者為空集合(稱為空二元樹),或者由一個節點和兩顆互不相交;且分別稱為根結點的左子樹和右子樹之二元樹所組成
  * 二元樹的定義: 1.每節點最多有兩棵子樹,所以在二元樹中,沒有度大於2個節點  2.左子樹和右子樹是有順序的,次序不能任意顛倒  3.即使樹中的某節點只有一棵子樹,也要區分它是左子樹還是右子樹
  * 今天先記錄這些

* 2018/3/21
  * 去丁家借東西,結果東西全沒借到,反而收到了兩件衣服回來XDDD
  * 讀 Diary of a Wimpy Kid 及文法
  * 昨天沒紀錄的繼續寫
  * 二元樹具有五種基本型態: 1.空二元樹 2.只有一個節點樹 3.根節點只有左子樹 4.根節點只有右子樹 5.根節點既有左子樹也有右子樹
  * 特殊二元樹: 1.斜樹 2.完滿二元樹 3.完整二元樹
  * 斜樹: 所有的節點都只有左子樹的稱做左斜樹; 所有節點都只有右子樹的稱為右斜樹
  * 完滿二元樹: 如果所有分支節點都存在左子樹和右子樹,且所有葉子都在同一階上,這樣的二元樹稱為完滿二元樹(Full Binary Tree)
  * 完整二元樹: 如果編號為i(1<i<=n)的節點,與同樣深度的完滿二元樹中編號為i的節點在二元樹中的位置完全相同,則這棵二元樹稱為完整二元樹(Complete Binary Tree) (就是逐階順序編號相同)
  * 完滿二元樹一定是完整二元樹,但完整二元樹不一定是完滿二元樹
  * 完整二元樹的特點: 1.葉子節點只能出現在最下兩階 2.最下階的葉子一定集中在左邊連續位置 3.倒數第二階,若有葉子節點,一定都在右邊連續位置 4.如果節點的度為1,則該節點只有左孩子 5.同樣節點數的二元樹,完整二元樹的深度最小
  * 二元樹的特性一: 在二元樹的第i階上至多有2^i-1個節點(i≧1)
  * 特性二: 深度為k的二元樹至多有(2^k)-1個節點(k≧1)
  * 特性三: 對任何一棵二元樹T,如果其終端節點數為n0,而度為2的節點數為n2,則n0=n2+1
  * 特性四: 具有n個節點的完整二元樹的深度為└㏒2 n┘+1 (└x┘表示不大於x的最大整數)  <<<符號不會打,打個大概而以
  * 特性五: 如果對一棵有n個節點的完整二元樹(其深度為(log2 n)+1)的節點逐階順序編號(從第1階到第(log2 n)+1階,每階從左到右)
  * 二元樹的每個節點最多有兩個孩子,所以,為它設計一個資料欄位和兩個指標欄位是比較自然的想法,我們稱這樣的鏈結串列為二元鏈結串列
  * 二元樹的走訪是指從根結點出發,按照某種次序依次拜訪二元樹中的所有節點,要拜訪每個節點一次且只能拜訪一次 (拜訪和次序為關鍵字)
  * 二元樹的走訪方式: 1.前序走訪 2.中序走訪 3.後序走訪 4.階序走訪
  * 前序走訪: 先拜訪根結點,然後前序走訪左子樹,在前序走訪右子樹
  * 中序走訪: 從根結點開始(不過並非先拜訪根結點),先中序走訪根結點的左子樹,然後拜訪根結點,最後中序走訪右子樹
  * 後序走訪: 從左到右,並從葉子節點後序走訪左子樹及右子樹,最後是拜訪根節點
  * 已知道的是前序和後序走訪,則無法確定一棵二元樹(要走中序才能確定)
  * 建立二元樹也是利用了遞迴的原理。只不過在原來應該是列印節點的地方,改成產生節點並傳值給節點操作

* 2018/3/22
  * 讀 Diary of a Wimpy Kid
  * 收到新課本,太感謝啦
  * 寫了程式卻跑不出來,明天再繼續處理 囧.............
